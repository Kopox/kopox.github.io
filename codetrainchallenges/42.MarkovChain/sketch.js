/*
	## Markov Chains ##

	This code is inspired from a Coding Challenge video made by Daniel Shiffman (The Coding Train)
	https://youtu.be/eGFJ8vugIWA
	
	A text is given as input. And object "grams" of order "order" is created, making a list of each "order" number of following letters (each "gram"). Each "gram" key is given an array as value pair, the array comprising all the possible letters following the "gram" in the text.
	A new text is generated by beginning with a few letters and iterating a given number of times as follow:
		look at the last "order" number of letter in the text (gram)
		choose a random letter in the array corresponding to the gram (in the object "grams")
		add it to the text
	Another loop was added to avoid ending the text in the middle of a sentence. This loop is similar to the previous one, but also checks if the letter added ends a sentence (.,!?). If so, end the loop.
*/
var txt = "";
var texts = []; // List of the source texts
var txtList = []; // List of the texts generated <p>
var textArea;
var submit;
var reset;
var randomText;

var grams = {};
var order = 5;

//function preload() {
//    txt = loadStrings("genie.txt");
//}

function setup() {
    noCanvas();
    initializeTexts();
    attributeButtons();
}

function draw() {
    
}

function newText() {
    txt = textArea.value();
    createGrams();
    generate();
}

function createGrams() {
    grams = [];
    for (var i = 0; i < txt.length - order; i++) {
        var gram = txt.substring(i, i + order);
        var next = txt.charAt(i + order);
        
        if (!grams[gram]) {
            grams[gram] = [];
        }
        grams[gram].push(next);
    }
}

function generate() {
    var text = txt.substring(0, order);
    var currentGram = "";
    var next = "";
    
    for (var i = 0; i < 2000; i++) {
        currentGram = text.substring(i, i + order);
        if (grams[currentGram]) {
            next = random(grams[currentGram]);
            text += next;
            if( i > 1000 && (next == "." || next == "!" || next == "?")) {
                break;
            }
        } else {
            break;
        }
    }
    
    txtList.push(createP(text));
}